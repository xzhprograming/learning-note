## algorithm



### 双指针

双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

1. **左右指针**

   > 查找回文串

2. **快慢指针**

   > 判断链表是否为循环链表
   
3. **滑动窗口**
   > leetcode3.无重复字符的最长子串
   > 使用HashSet存储滑动窗口中的字符，在原始字符串上使用滑动窗口进行移动
   > 根据条件判断左右指针交替移动
   > 
   > leetcode76.最小覆盖子串
   > 使用HashMap1存储模板串，字符最为key，其字符的频数(即字符出现的次数)作为value。统		计频数是为了防止模板串中含有重复字符。
   > 创建待匹配串的HashMap2作为滑动窗口，存储当前访问得到的字符。
   > 将左右指针同时指向头部，左右指针根据条件交替进行移动，同时更新HashMap2。
   > 左右指针的移动即窗口的移动，需要仔细判断窗口缩小和增大的条件。
   > 适用于求解子串，子数组的问题
+ **编程技巧**
	

	> 1. 若要左指针和右指针都要访问第一个节点可以将left设置为0，right设置为-1，
	>    right移动时访问right + 1.
	>
	> 2. 遇到链表需要访问head头结点的前一个节点，
	>    可以增加一个虚拟节点dummyNode，使其
>    dymmyNode.next = head;
	>
	> 3. 二分查找判断中点位置写法
	>
	>    int mid = (low + high) / 2; 
	>
	>    int mid = low + (high - low) / 2; // 防止第一种写法中low + high的值溢出 ，只要low不为负值


​	
​	

### 二叉树

1. 树的递归遍历（DFS）

   先序遍历、中序遍历、后序遍历

2. 树的非递归遍历

   如：树的中序遍历、先序遍历
   
   使用栈依次压入树的左节点，若左节点为空则将节点弹出，对节点进行操作后，将其右节点压入栈中，再次循环进行操作，直到栈为空。
   
   树的后序遍历
   
   在遍历过程中需要对遍历过的节点进行标记操作，以防重复操作一个节点。
   
3. 树的层次遍历（BFS）

   利用队列先将root节点加入队列中，然后依次将left和right节点加入队列

4. 树的遍历扩展

   求二叉树的节点数

   求二叉树的高度、二叉树的最小高度

   判断二叉树是否对称、翻转二叉树使其对称

   先序和中序遍历序列构造二叉树

   后序和中序遍历序列构造二叉树

5. 二叉排序树（BST）

   BST第K小的元素

   二叉搜索树转累加树

   验证二叉搜索树

   删除二叉搜索树中的节点

### 动态规划

+ 动态规划思想：
> 若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解
>
+ 适用情况：
1. 问题具有最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

### 回溯法

**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

回溯算法的框架：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**

不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。

https://pic.leetcode-cn.com/1598110600-YEeVKF-image.png

### 递归

+ 三个问题：
  1. 函数的定义是什么？
  2. 函数的输入是什么？
  3. 函数的输出是什么？
+ 分析函数的写法
  	1. 递归终止的条件
   	2. 返回值
   	3. 函数内容


### 排序算法
+ 冒泡排序
+ 选择排序
+ 快速排序
+ 堆排序
+ 归并排序

